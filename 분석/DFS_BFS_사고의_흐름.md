# DFS/BFS

## DFS (Depth First Search) : 깊이 우선 탐색

: 트리나 그래프에서 한 루트로 최대한 깊숙이 들어가며 탐색

- 이용 대상 : 트리, 그래프
- 확장 : 백트래킹, 미로제작 알고리즘

- 구현 : LIFO(Last In First Out) ⇒ Stack의 형태이다.
    
    1) 재귀 호출을 통하여 구현 (함수 호출 Stack 이용)
    
    장 : Stack 자료구조 없이 구현 가능
    
    단 : 함수 호출시 마다 Overhead가 발생하며, 전달 인자 및 함수 정보가 메모리상에 많이 차지
    
    2) Stack 자료구조를 통하여 구현
    
    장 : 재귀 호출의 단점을 보완 가능하다. (변수의 재활용성)
    
    단 : 상대적으로 코드의 쓰기성(Writability) 및 가독성(Readability)이 떨어진다
    
- 장점
    
    BFS에 비해 메모리 사용량이 적다. (BFS는 분기점에 대해 모든 경로를 추적및 저장해야하는 반면, DFS는 탐색중인 경로에 대해서만 저장한다)
    
- 단점
    
    얻어낸 경로가 최적해라는 보장이 없다.
    
    즉 최적해를 구하기 위해서는 모든 경우에 대한 경로를 탐색하고 비교하는 과정을 필요로 한다.
    

⇒ 데이터를 순회하는 경우, 순환을 찾는 경우등에 이용

---

## BFS (Breadth First Search) : 너비 우선 탐색

: 트리나 그래프에서 같은 수준의 Vertex를 우선적으로 방문하며 탐색

⇒ 분기점에서 가능한 모든 경우를 고려하며 탐색

- 이용 대상 : 트리, 그래프
- 확장 :

- 구현 : FIFO(First In First Out) ⇒ Queue의 형태이다.
- 장점 :
    
    최적해를 구할 수 있다
    
    (=가중치가 없는 그래프의 최단경로를 알아낼 수 있다)
    
    탐색 깊이가 거의 무한한 경우, DFS로는 탐색 불가능 하여도 BFS로는 가능하다
    
- 단점 :
    
    여러 정점에 대한 탐색을 동시에 시행하기 때문에 DFS에 비해 많은 메로리를 필요로 한다
    
    Queue 자료구조를 필요로 한다 
    

⇒ 가중치가 없는 최단 경로를 구하는 경우,  탐색 깊이가 거의 무한에 가까워 질 수 있는 경우

---

# 11724 : 연결 요소의 개수

[https://www.acmicpc.net/problem/11724](https://www.acmicpc.net/problem/11724)

문제 요약 | 방향 없는 그래프의 연결 요소 개수를 구하기

문제 제한 | 3초 | 512MB

입력 조건 | 1 ≤ VertexNum ≤ 1000, 0 ≤ M ≤ N*(N-1)/2

사고의 흐름 |

Graph 자료구조, 많지 않은 정점의 수, 많은 수의 간선 ⇒ Matrix 행렬을 이용한 Graph 표현

순회, DFS? BFS? 구현하기 쉬운 BFS 선택, queue 이용

/* ! 이 시점에서 구현하기 쉬운지 여부가 아닌, 메모리 제한을 바탕으로 접근하여야 했다.

 *   최대 정점의 개수 1,000 ⇒ 최대 Queue 크기 999 ⇒ 4(int) * 999 ⇒ 약 4KB 큰 문제 없다.

 *   DFS, BFS크게 상관이 없다.

 */

 

모든 정점을 시작점으로 순회, isVisit 배열을 만들어 중복 방문 제거, 순회 횟수 return

 

풀이 후 개선 점 |

1. mat을 int형으로 동적할당
    
    ⇒ 정점의 수가 많지 않은점, 연결 여부만 저장하면 된다는 점을 고려하여
    
    bool형 static 2차원 배열로 제작하는 편이 좋다 생각
    
    ⇒ 동적할당, 초기화, 해제의 필요성 사라짐
    
2. isVisit을 동적할당
    
    ⇒ vector<bool>을 이용하는 편이 더 안정적
    
    습관적으로 동적할당 하는 버릇 고치기 ⇒ vector를 이용할 것
    

 

---

# 2023 : 신기한 소수

[https://www.acmicpc.net/problem/2023](https://www.acmicpc.net/problem/2023)

문제 요약 | 조건을 만족하는 특수한 소수 구하기

문제 제한 | 2초 | 4MB

입력 조건 | 1 ≤ N ≤ 8

사고의 흐름 |

N 자리 소수 = N-1자리 소수 + 소수를 이어붙인 수 중에 소수인 수

⇒ 재귀

넓은 범위의 소수 대상 → 에라스토테네스의 체 → 10^8 → 약 100 MB 메모리 초과

⇒ 1) 범위의 제곱근까지 에라스토테네스의 체 → 10^4 ⇒ 약 10KB

     2) 범위를 초과하는 수는 주어진 체를 기반으로 소수 여부 계산

풀이 후 개선 점 |

getAmazingPrimeArr의 반환값이 vector의 동적할당 주소인데

안정성이 크게 떨어질 수 있다.

Queue를 외부에서 만들고, Queue*를 전달하여

하나의 큐로 모든 과정이 이루어지게 하는편이 더 효율적이고 안정적이다.

재귀적인 성질만 이용할 것이 아닌, 출제 의도에 맞도록 BFS로 접근하는 것이 더 올바랐을 것

1자리 소수 → 2자리 소수 → 3자리 신기한 소수 …

---

# 13023 : ABCDE

[https://www.acmicpc.net/problem/13023](https://www.acmicpc.net/problem/13023)

문제 요약 | 깊이가 5이상인 경로가 존재하는지 구하기

문제 제한 | 2초 | 512MB

입력 조건 | 5 ≤ peopleNum ≤ 2000, 1 ≤ edge ≤ 2000

사고의 흐름 |

그래프 문제이니 11724문제의 기존 코드를 재활용 해보자 ^~^ → 시간 초과

문제의 조건에서 정점에 비해 적은수의 친구관계의 수가 주어진다는 사실 인식

⇒ 연결리스트의 표현 이용, 

DFS를 이용하여 빠르게 깊이 탐색

(성공)

만약 코드의 중간에 종료 조건을 넣지 않고, 최대 깊이를 계산한 이후 최대 깊이가 5보다 큰지 비교? → 시간 초과

풀이 후 개선점 | 

그래프 문제를 풀기 이전에 행렬을 사용할지, 인접 리스트를 사용할지 명확히 할 것.

DFS를 요구하는 문제인지, BFS를 요구하는 문제인지 구분하고 구현할 것

---

# 1260 : DFS와 BFS

[https://www.acmicpc.net/problem/1260](https://www.acmicpc.net/problem/1260)

문제 요약 | DFS와 BFS를 구현하기

문제 제한 | 2초 | 128MB

입력 조건 | 1 ≤ vertexNum ≤ 1000, 1≤ edgeNum ≤ 10,000

사고의 흐름 |

정점의 수에 비해 간선의 수가 적음으로 Liked List형태의 그래프 표현

DFS, BFS는 각각 Stack, Queue 자료형을 이용하여 구하자

풀이 후 개선점 |

? 입력값 매순간 삽입 정렬 vs 입력 후 정렬

쉽게 비교할 수 있는 형태는 아닌 듯 하다. 하지만 평균 1개의 정점당 10개 이하의 정점을 가진다는 점과, 배열이 한 덩어리가 아닌 vertexNum개의 배열로 나누어져 있다는 점에서 오히려 insertion sort가 좋을 것 같다. 

visited배열 bool형으로도 가능하다

---

# 2178 : 미로 탐색

[https://www.acmicpc.net/problem/2178](https://www.acmicpc.net/problem/2178)

문제 요약 | 미로 탐색하기

문제 제한 | 1초 | 192MB

입력 조건 | 2 ≤ high, width ≤ 100

사고의 흐름 |

최소의 칸수를 구한다는 점에서 BFS를 사용할 것

Point 구조체를 만들어 x, y좌표, 현재까지의 칸수를 저장 한다.

⇒ 메모리 초과

??? Point 구조체 최초 사이즈 : 12 byte 

12 byte * 100 * 100 = 120KB…? ≤ 192MB

Point 구조체를 크기를 최소화 : 4 byte (char, char, short)

⇒ 메모리 초과

원인 : 앞으로 탐색할 대상에 대해 중복이 발생 가능하다.

→ 앞으로 탐색할 대상을 visit 처리 (중복 제거)

⇒ 성공

풀이 후 개선점 |

입력 행렬의 크기가 상당히 작다는 점에서 static 으로 관리할 것

→ 동적 할당 및 초기화 및 해제 절약

4방향 이동에 대하여 사전의 배열 및 for문을 이용하여 코드의 길이를 줄일것 (code 참조)